package go_as

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"regexp"
	"strings"
	"time"

	mcpcore "github.com/mark3labs/mcp-go/mcp"
)

// Agent struct represents a new kind of agent that is decoupled from the LLM during task execution.
type Agent struct {
	llmClient      *LLMClient
	mcpClients     map[string]*MCPClient
	logger         *slog.Logger
	history        []Message // Full conversation history for the LLM
	availableTools []Tool    // Tools fetched from MCPs

	// New fields for multi-step orchestration
	currentPlan    []string // Stores the high-level plan generated by the Orchestrator persona
	currentStepIdx int      // Tracks which step of the plan Nexus is currently on
	originalQuery  string   // Store the initial user query for consistent context
}

// NewAgent creates a new instance of the Agent.
func NewAgent(llmClient *LLMClient, mcpClients map[string]*MCPClient, logger *slog.Logger, availableTools []Tool) *Agent {
	return &Agent{
		llmClient:      llmClient,
		mcpClients:     mcpClients,
		logger:         logger,
		history:        []Message{},
		availableTools: availableTools,
		currentPlan:    nil,
		currentStepIdx: 0,
		originalQuery:  "",
	}
}

// Execute is responsible for executing the agent's tasks.
func (a *Agent) Execute(ctx context.Context, query string) (string, error) {
	a.originalQuery = query
	a.history = []Message{{Role: "user", Content: query}}

	// --- Phase 1: Orchestrator (Planning) ---
	a.logger.Info("Agent: Entering Orchestrator (Planning) phase.")
	orchestratorMessages := append([]Message{{Role: "system", Content: getOrchestratorSystemPrompt(a.availableTools)}}, a.history...)
	llmResponse, err := a.llmClient.CallChatCompletion(ctx, orchestratorMessages, a.availableTools)
	if err != nil {
		return "", fmt.Errorf("orchestrator planning failed: %w", err)
	}
	message := llmResponse.Choices[0].Message
	a.history = append(a.history, message)

	// Parse the plan from the LLM's response
	planContent, found := extractContentBetweenTags(message.Content, "<plan>", "</plan>")
	if !found {
		a.logger.Error("Agent: Orchestrator did not provide a parsable plan.", "llm_response_content", message.Content)
		return "", fmt.Errorf("orchestrator did not provide a parsable plan in its response")
	}
	a.currentPlan = parseNumberedList(planContent)
	a.logger.Info("Agent: Generated plan.", "plan", strings.Join(a.currentPlan, "; "))

	// Check for an immediate tool call from the planning phase
	var firstToolCall *ToolCall
	if message.ToolCalls != nil && len(message.ToolCalls) > 0 {
		firstToolCall = &message.ToolCalls[0]
		a.logger.Info("Agent: First action is a tool call.", "tool", firstToolCall.Function.Name)
	}

	// --- Phase 2: Nexus (Execution Loop) ---
	a.logger.Info("Agent: Entering Nexus (Execution) phase.")
	for {
		// If the LLM provided a final answer and no more tools, we're done.
		if message.Content != "" && (message.ToolCalls == nil || len(message.ToolCalls) == 0) {
			a.logger.Info("Agent: Nexus provided final answer.")
			return message.Content, nil
		}

		// Execute the tool call if one was recommended
		if firstToolCall != nil { // Handle the tool call potentially generated during planning
			a.logger.Info("Agent: Executing first planned tool call.", "tool", firstToolCall.Function.Name, "arguments", firstToolCall.Function.Arguments)
			toolResult, execErr := a.executeToolCall(ctx, firstToolCall)
			if execErr != nil {
				toolResultMsg := Message{Role: "tool", Content: fmt.Sprintf("Tool execution failed: %v", execErr)}
				a.logger.Error("Agent: Tool execution failed.", "tool", firstToolCall.Function.Name, "error", execErr)
				a.history = append(a.history, toolResultMsg)
			} else {
				synthesizer := NewSynthesizer()
				synthesizedResult, err := synthesizer.Synthesize(toolResult)
				if err != nil {
					return "", fmt.Errorf("failed to synthesize tool result: %w", err)
				}
				toolResultMsg := Message{Role: "tool", Content: synthesizedResult}
				a.history = append(a.history, toolResultMsg)
				a.logger.Info("Agent: Tool execution successful.", "tool", firstToolCall.Function.Name, "result", synthesizedResult)
			}
			firstToolCall = nil // Clear after first execution
			a.currentStepIdx++  // Increment step after execution
		} else {
			// Get the next action from Nexus based on the plan and history
			a.logger.Info("Agent: Requesting next action from Nexus.", "current_step_idx", a.currentStepIdx, "plan_length", len(a.currentPlan))
			nexusMessages := append([]Message{{Role: "system", Content: getNexusSystemPrompt(a.originalQuery, a.currentPlan, a.currentStepIdx, a.availableTools)}}, a.history...)
			llmResponse, err = a.llmClient.CallChatCompletion(ctx, nexusMessages, a.availableTools)
			if err != nil {
				return "", fmt.Errorf("nexus execution failed: %w", err)
			}
			message = llmResponse.Choices[0].Message
			a.history = append(a.history, message)

			if message.ToolCalls != nil && len(message.ToolCalls) > 0 {
				// Nexus recommended a tool, execute it
				a.logger.Info("Agent: Nexus recommended tool.", "tool", message.ToolCalls[0].Function.Name, "arguments", message.ToolCalls[0].Function.Arguments)
				toolResult, execErr := a.executeToolCall(ctx, &message.ToolCalls[0])
				if execErr != nil {
					toolResultMsg := Message{Role: "tool", Content: fmt.Sprintf("Tool execution failed: %v", execErr)}
					a.logger.Error("Agent: Tool execution failed.", "tool", message.ToolCalls[0].Function.Name, "error", execErr)
					a.history = append(a.history, toolResultMsg)
				} else {
					synthesizer := NewSynthesizer()
					synthesizedResult, err := synthesizer.Synthesize(toolResult)
					if err != nil {
						return "", fmt.Errorf("failed to synthesize tool result: %w", err)
					}
					toolResultMsg := Message{Role: "tool", Content: synthesizedResult}
					a.history = append(a.history, toolResultMsg)
					a.logger.Info("Agent: Tool execution successful.", "tool", message.ToolCalls[0].Function.Name, "result", synthesizedResult)
				}
				a.currentStepIdx++ // Increment step after successful execution
			} else {
				// Nexus did not recommend a tool. It might be done or stuck.
				if llmResponse.Choices[0].FinishReason == "stop" && message.Content != "" {
					a.logger.Info("Agent: Nexus indicated task completion with a final answer.")
					return message.Content, nil // Final answer provided by Nexus
				} else {
					// This indicates Nexus might be stuck or unable to proceed.
					a.logger.Warn("Agent: Nexus did not recommend a tool and did not provide a final answer. Potentially stuck.", "llm_response_content", message.Content, "finish_reason", llmResponse.Choices[0].FinishReason)
					return "", fmt.Errorf("nexus agent unable to complete task: %s", message.Content) // Or a more specific error
				}
			}
		}
	}
}

// executeToolCall is responsible for executing a tool call.
func (a *Agent) executeToolCall(ctx context.Context, toolCall *ToolCall) (*mcpcore.CallToolResult, error) {
	a.logger.Info("Executing tool call", "tool_name", toolCall.Function.Name, "arguments", toolCall.Function.Arguments)

	parts := strings.SplitN(toolCall.Function.Name, ".", 2)
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid tool name format from LLM: %s", toolCall.Function.Name)
	}
	agentAlias := parts[0]
	toolName := parts[1]

	client, ok := a.mcpClients[agentAlias]
	if !ok {
		return nil, fmt.Errorf("agent %s not connected", agentAlias)
	}

	var toolArgs map[string]interface{}
	if err := json.Unmarshal([]byte(toolCall.Function.Arguments), &toolArgs); err != nil {
		return nil, fmt.Errorf("failed to unmarshal tool arguments: %w", err)
	}

	ctx, cancel := context.WithTimeout(ctx, 30*time.Second) // Longer timeout for tool execution
	defer cancel()

	result, err := client.CallTool(ctx, toolName, toolArgs)
	if err != nil {
		return nil, fmt.Errorf("tool execution failed: %w", err)
	}

	if result.IsError {
		return nil, fmt.Errorf("tool call failed with error: %s", result.Content[0].(mcpcore.TextContent).Text)
	}

	return result, nil
}

func getOrchestratorSystemPrompt(tools []Tool) string {
	formattedTools := formatToolsForLLM(tools)

	return fmt.Sprintf(`You are the 'Nexus Orchestrator', an intelligent system designed to strategically plan and initiate the execution of complex user requests using a suite of tools. Your primary goal is to create a clear, step-by-step plan and then recommend the first action.

Your Process:

Analyze the User Request: Fully understand the user's ultimate goal.

Formulate a Step-by-Step Plan: If the request requires multiple actions, intermediate data handling, or sequential tool use, create a numbered plan.

State the logical steps required to achieve the user's goal.

Identify which specific tool (from 'Available Tools') will be used for each step.

Explicitly mention any data flow between steps (e.g., "Use the output of Step 1 as input for Step 2").

Keep the plan concise but comprehensive.

Recommend the First Action: After outlining the plan, immediately recommend the tool call for the first step of the plan.

Available Tools (for your planning):
%s

Your Output Format:
First, state your complete plan in a numbered list, wrapped in  and  XML-like tags.
Then, on a new line, recommend the first tool call as a JSON object in the 'tool_calls' format. If the task is simple and requires no tools, output {"tool_calls": []} followed by your final answer.

Example Plan & First Action:

<plan>
1. Search for NASCAR related websites using the 'internet_search.search' tool.
2. Extract relevant URLs from the search results.
3. Write the extracted URLs to the specified file using the 'filesys_utils.write_file' tool.
</plan>

{"tool_calls": [{"id": "call_123", "type": "function", "function": {"name": "internet_search.search", "arguments": "{\"query\": \"NASCAR websites\"}"}}]}`,
		formattedTools,
	)
}

func getNexusSystemPrompt(originalQuery string, plan []string, currentStepIdx int, tools []Tool) string {
	formattedTools := formatToolsForLLM(tools)
	currentPlanStep := ""
	if currentStepIdx < len(plan) {
		currentPlanStep = plan[currentStepIdx]
	}

	return fmt.Sprintf(`You are 'Nexus', the execution engine. Your task is to precisely execute the *next step* of the established plan. You must adhere to the plan and prioritize efficient action.
Original User Request:
%s

The Overall Plan:
%s

Current Step (Step %d):
%s

Available Tools for Execution:
%s

Your Process:

Execute the Current Step: Based on the 'Current Step', the 'Original User Request', and the 'Conversation History', determine the exact tool call needed.

Parameter Precision: Only include parameters that are explicitly provided in the user's original request or are absolutely essential for this specific step. Prefer to use tool's default values by omitting parameters if not explicitly needed.

Error Handling: If a tool call in the 'Conversation History' resulted in an error, analyze it. If the error prevents completing the current step, either try an alternative approach (if possible within the plan) or state that the task cannot be completed and why.

Task Completion: If this step completes the overall plan, or if no more tools are needed to fulfill the 'Original User Request', provide the final summary/answer. If the plan is complete and no more tools are needed, respond with {"tool_calls": []} and then your final answer.

No Tool Needed for Current Step: If the current step (or the overall task) doesn't require a tool, output {"tool_calls": []} and provide a direct textual response.

Conversation History:
[This will be automatically appended by the LLM client, but the prompt emphasizes its importance]

Your Next Tool Recommendation or Final Answer:`,
		originalQuery,
		strings.Join(plan, "\n"),
		currentStepIdx+1,
		currentPlanStep,
		formattedTools,
	)
}

func formatToolsForLLM(tools []Tool) string {
	var builder strings.Builder
	for _, tool := range tools {
		builder.WriteString(fmt.Sprintf("- Tool Name: %s\n", tool.Function.Name))
		builder.WriteString(fmt.Sprintf("  Description: %s\n", tool.Function.Description))
		params, _ := json.MarshalIndent(tool.Function.Parameters, "  ", "  ")
		builder.WriteString(fmt.Sprintf("  Parameters:\n%s\n", string(params)))
	}
	return builder.String()
}

func extractContentBetweenTags(text, startTag, endTag string) (string, bool) {
	re := regexp.MustCompile(fmt.Sprintf(`(?s)%s(.*?)%s`, regexp.QuoteMeta(startTag), regexp.QuoteMeta(endTag)))
	matches := re.FindStringSubmatch(text)
	if len(matches) > 1 {
		return strings.TrimSpace(matches[1]), true
	}
	return "", false
}

func parseNumberedList(text string) []string {
	re := regexp.MustCompile(`\d+\.\s+(.*)`)
	matches := re.FindAllStringSubmatch(text, -1)
	var items []string
	for _, match := range matches {
		if len(match) > 1 {
			items = append(items, strings.TrimSpace(match[1]))
		}
	}
	return items
}
